"""
Kickstart Engine — Generates or modifies kickstart files for automated installation.
Handles: partitioning, user setup, package selection, post-install scripts.
"""

import os
from pathlib import Path
from datetime import datetime


class KickstartEngine:
    """Generate and manage kickstart configurations."""

    def __init__(self, iso_root: Path, manifest: dict):
        self.iso_root = iso_root
        self.manifest = manifest
        self.ks_config = manifest.get("kickstart", {})
        self.branding = manifest.get("branding", {})
        self.name = manifest["name"]
        self.version = manifest["version"]
        self.os_id = self.branding.get("os_id", self.name.lower().replace(" ", "-"))

    def generate(self, packages_install=None, packages_remove=None, repo_configs=None):
        """Generate or modify the kickstart file and place it on the ISO."""
        print("⚙️  Generating kickstart...")

        template_path = self.ks_config.get("template")
        if template_path and Path(template_path).exists():
            content = Path(template_path).read_text()
            print(f"  → Using template: {template_path}")
        else:
            content = self._generate_default(
                packages_install or [],
                packages_remove or [],
                repo_configs or []
            )
            print("  → Generated default kickstart")

        # Write kickstart to ISO root
        ks_path = self.iso_root / "ks.cfg"
        ks_path.write_text(content)

        # Update boot configs to use kickstart
        self._inject_ks_boot_param()

        print("  ✅ Kickstart configured")
        return ks_path

    def _generate_default(self, packages_install, packages_remove, repo_configs):
        """Generate a complete default kickstart file."""

        tz = self.ks_config.get("timezone", "UTC")
        lang = self.ks_config.get("lang", "en_US.UTF-8")
        keyboard = self.ks_config.get("keyboard", "us")
        selinux = self.manifest.get("selinux", "enforcing")

        # Root password
        root_pw_line = "rootpw --lock"
        if self.ks_config.get("root_password_value"):
            root_pw_line = f"rootpw --plaintext {self.ks_config['root_password_value']}"

        # GUI target
        gui = self.manifest.get("gui", {})
        if gui.get("enabled"):
            display_mode = "graphical"
            default_target = "graphical.target"
        else:
            display_mode = "text"
            default_target = "multi-user.target"

        # Firewall
        firewall_line = "firewall --enabled --service=ssh"
        if self.manifest.get("firewall"):
            services = self.manifest.get("firewall_services", ["ssh"])
            if services:
                svc_str = ",".join(services)
                firewall_line = f"firewall --enabled --service={svc_str}"
        else:
            firewall_line = "firewall --disabled"

        # Build packages section
        pkg_lines = ["%packages"]
        pkg_lines.append("@core")

        if gui.get("enabled"):
            desktop = gui.get("desktop", "GNOME").lower()
            desktop_groups = {
                "gnome": "@gnome-desktop",
                "kde": "@kde-desktop-environment",
                "xfce": "@xfce-desktop",
                "mate": "@mate-desktop",
                "cinnamon": "@cinnamon-desktop",
            }
            if desktop in desktop_groups:
                pkg_lines.append(desktop_groups[desktop])

        for pkg in packages_install:
            pkg_lines.append(pkg)

        for pkg in packages_remove:
            pkg_lines.append(f"-{pkg}")

        pkg_lines.append("%end")

        # Build repo lines
        repo_lines = ""
        for repo in repo_configs:
            repo_lines += f"\n# Custom repo: {repo['name']}\n"

        # Build %post script
        post_script = self._generate_post_script(repo_configs)

        # Assemble kickstart
        ks = f"""# {self.name} {self.version} — Kickstart Configuration
# Generated by Distro Forge on {datetime.now().strftime('%Y-%m-%d %H:%M')}
# ─────────────────────────────────────────────────

# Installation mode
{display_mode}

# System language and keyboard
lang {lang}
keyboard --vckeymap={keyboard} --xlayouts='{keyboard}'

# Timezone
timezone {tz} --utc

# Network (DHCP by default)
network --bootproto=dhcp --activate
network --hostname={self.os_id}

# Root password
{root_pw_line}

# Create a default user (user can change during install)
# user --name=admin --groups=wheel --plaintext --password=changeme

# SELinux
selinux --{selinux}

# Firewall
{firewall_line}

# Partitioning — auto with LVM
ignoredisk --only-use=sda
autopart --type=lvm
clearpart --all --initlabel

# Bootloader
bootloader --append="crashkernel=auto" --location=mbr

# Reboot after install
reboot --eject
{repo_lines}
# ── Packages ─────────────────────────────────────
{chr(10).join(pkg_lines)}

# ── Post-install script ──────────────────────────
{post_script}
"""
        return ks

    def _generate_post_script(self, repo_configs):
        """Generate the %post section for branding and config."""

        lines = [
            "%post --log=/root/distro-forge-post.log",
            "",
            f"echo '=== {self.name} post-install ==='",
            "",
            "# ── Branding ──────────────────────────────────",
            "",
            "# os-release",
            "cat > /etc/os-release << 'OSRELEASE_EOF'",
            f'NAME="{self.name}"',
            f'VERSION="{self.version}"',
            f'ID="{self.os_id}"',
            f'ID_LIKE="rhel centos fedora"',
            f'VERSION_ID="{self.version}"',
            f'PRETTY_NAME="{self.name} {self.version}"',
            f'ANSI_COLOR="0;31"',
            f'CPE_NAME="cpe:/o:{self.os_id}:{self.os_id}:{self.version}"',
            "OSRELEASE_EOF",
            "",
            "# system-release",
            f'echo "{self.name} release {self.version}" > /etc/system-release',
            f'echo "{self.name} release {self.version}" > /etc/redhat-release',
            "",
            "# MOTD",
            "cat > /etc/motd << 'MOTD_EOF'",
            "",
            f"  Welcome to {self.name} {self.version}",
            f"  {'─' * (len(self.name) + len(self.version) + 14)}",
            "",
            "MOTD_EOF",
            "",
            "# issue",
            "cat > /etc/issue << 'ISSUE_EOF'",
            f"{self.name} {self.version}",
            "Kernel \\r on an \\m",
            "",
            "ISSUE_EOF",
            "cp /etc/issue /etc/issue.net",
            "",
        ]

        # Custom repos
        if repo_configs:
            lines.append("# ── Custom Repositories ───────────────────────")
            lines.append("")
            for repo in repo_configs:
                lines.append(f"cat > /etc/yum.repos.d/{repo['name']}.repo << 'REPO_EOF'")
                lines.append(repo["content"].strip())
                lines.append("REPO_EOF")
                lines.append("")

        # Default target
        gui = self.manifest.get("gui", {})
        if gui.get("enabled"):
            lines.append("# Set graphical target")
            lines.append("systemctl set-default graphical.target")
        else:
            lines.append("# Set multi-user target")
            lines.append("systemctl set-default multi-user.target")
        lines.append("")

        # Post-install scripts from manifest
        post_scripts = self.manifest.get("post_scripts", [])
        if post_scripts:
            lines.append("# ── Custom post-install scripts ──────────────")
            for script_path in post_scripts:
                if Path(script_path).exists():
                    lines.append(f"# --- {script_path} ---")
                    lines.append(Path(script_path).read_text())
                    lines.append("")
                else:
                    lines.append(f"# WARNING: Script not found: {script_path}")

        lines.append(f"echo '{self.name} {self.version} installation complete.'")
        lines.append("")
        lines.append("%end")

        return "\n".join(lines)

    def _inject_ks_boot_param(self):
        """Add inst.ks parameter to boot configurations."""

        # GRUB config
        for grub_path in [
            self.iso_root / "EFI" / "BOOT" / "grub.cfg",
            self.iso_root / "boot" / "grub2" / "grub.cfg",
        ]:
            if grub_path.exists():
                content = grub_path.read_text()
                # Add inst.ks to kernel boot lines if not already present
                if "inst.ks" not in content:
                    # Match linuxefi or linux lines with boot params
                    import re
                    content = re.sub(
                        r"(linux(?:efi)?\s+\S+\s+.*?)(\s*\n)",
                        r"\1 inst.ks=cdrom:/ks.cfg\2",
                        content
                    )
                    grub_path.write_text(content)

        # isolinux config
        isolinux_cfg = self.iso_root / "isolinux" / "isolinux.cfg"
        if isolinux_cfg.exists():
            content = isolinux_cfg.read_text()
            if "inst.ks" not in content:
                import re
                content = re.sub(
                    r"(append\s+.*?)(\s*\n)",
                    r"\1 inst.ks=cdrom:/ks.cfg\2",
                    content
                )
                isolinux_cfg.write_text(content)
